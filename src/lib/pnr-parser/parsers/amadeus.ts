/**
 * Amadeus PNR é›»å ±è§£æå™¨
 */

import { logger } from '@/lib/utils/logger';
import {
  ParsedPNR,
  PassengerInfo,
  ValidationResult,
  ParsedFareData,
  TaxItem,
  SSRCategory,
  OSICategory,
} from '../types';
import { mergeMultilineEntries, parseAmadeusDate, parseEnhancedSSR, parseEnhancedOSI } from '../utils';

/**
 * é©—è­‰ AMADEUS PNR æ ¼å¼
 */
export function validateAmadeusPNR(rawPNR: string): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  const suggestions: string[] = [];

  const lines = rawPNR.split('\n').map(line => line.trim()).filter(Boolean);

  if (lines.length === 0) {
    errors.push('é›»å ±å…§å®¹ä¸èƒ½ç‚ºç©º');
    return { isValid: false, errors, warnings, suggestions };
  }

  const hasHeader = lines.some(line => line.startsWith('RP/'));
  if (!hasHeader) {
    warnings.push('å»ºè­°åŒ…å«Headerè³‡è¨Š (RP/...)');
  }

  const hasValidNames = lines.some(line => /\d+\.[A-Z]+\/[A-Z]+/g.test(line));
  if (!hasValidNames) {
    errors.push('æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ—…å®¢å§“åæ ¼å¼ (ä¾‹: 1.SMITH/JOHN)');
  }

  const hasFlightSegments = lines.some(line =>
    /^\d+\s+[A-Z0-9]{2}\s+\d{1,4}\s+[A-Z]\s+\d{2}[A-Z]{3}/i.test(line));
  if (!hasFlightSegments) {
    warnings.push('æœªæ‰¾åˆ°èˆªç­è³‡è¨Š');
  }

  const hasTicketingDeadline = lines.some(line =>
    /(?:ON OR BEFORE|BEFORE)\s+\d{2}[A-Z]{3}/i.test(line));
  if (!hasTicketingDeadline) {
    suggestions.push('å»ºè­°åŒ…å«å‡ºç¥¨æœŸé™è³‡è¨Š');
  }

  lines.forEach((line, idx) => {
    if (line.match(/^SR[A-Z]{4}/i)) {
      const match = line.match(/^SR([A-Z]{4})(?:-(.+?))?(?:\/S(\d+(?:-\d+)?))?(?:\/P(\d+))?/i);
      if (!match) {
        warnings.push(`ç¬¬${idx + 1}è¡ŒSSRæ ¼å¼å¯èƒ½ä¸æ­£ç¢º: ${line}`);
      }
    }
  });

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    suggestions
  };
}

/**
 * å¾ Amadeus é›»å ±è§£æç¥¨åƒ¹è³‡è¨Š
 */
export function parseFareFromTelegram(rawPNR: string): ParsedFareData | null {
  const lines = rawPNR.split('\n').map(line => line.trim());
  const fullText = rawPNR.toUpperCase();

  let currency = 'TWD';
  let baseFare: number | null = null;
  let taxes: number | null = null;
  let totalFare: number | null = null;
  let fareBasis: string | null = null;
  let validatingCarrier: string | null = null;
  const taxBreakdown: TaxItem[] = [];
  let perPassenger = true;
  const rawFareLines: string[] = [];

  const fvMatch = fullText.match(/FV\s+([A-Z]{2})/);
  if (fvMatch) {
    validatingCarrier = fvMatch[1];
  }

  const fbMatch = fullText.match(/(?:K\s+FB-?|FBA-?)\s*([A-Z0-9]+)/i);
  if (fbMatch) {
    fareBasis = fbMatch[1];
  }

  for (const line of lines) {
    const upperLine = line.toUpperCase();

    const kFareMatch = upperLine.match(/K\s+FARE\s+([A-Z]{3})[\s]*([\d,]+(?:\.\d{2})?)/);
    if (kFareMatch) {
      currency = kFareMatch[1];
      baseFare = parseFloat(kFareMatch[2].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const kTaxMatch = upperLine.match(/K\s+TAX\s+(?:([A-Z]{3})[\s]*)?([\d,]+(?:\.\d{2})?)/);
    if (kTaxMatch) {
      if (kTaxMatch[1]) currency = kTaxMatch[1];
      taxes = parseFloat(kTaxMatch[2].replace(/,/g, ''));
      rawFareLines.push(line);

      const taxCodeMatch = upperLine.match(/([\d.]+)([A-Z]{2})/g);
      if (taxCodeMatch) {
        for (const match of taxCodeMatch) {
          const [, amount, code] = match.match(/([\d.]+)([A-Z]{2})/) || [];
          if (amount && code) {
            taxBreakdown.push({ code, amount: parseFloat(amount) });
          }
        }
      }
      continue;
    }

    const kTotalMatch = upperLine.match(/K\s+TOTAL\s+([A-Z]{3})[\s]*([\d,]+(?:\.\d{2})?)/);
    if (kTotalMatch) {
      currency = kTotalMatch[1];
      totalFare = parseFloat(kTotalMatch[2].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const fareMatch = upperLine.match(/^FARE\s+([A-Z]{3})[\s]*([\d,]+(?:\.\d{2})?)/);
    if (fareMatch) {
      currency = fareMatch[1];
      baseFare = parseFloat(fareMatch[2].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const taxMatch = upperLine.match(/^TAX\s+(?:([A-Z]{3})[\s]*)?([\d,]+(?:\.\d{2})?)/);
    if (taxMatch) {
      const taxAmount = parseFloat(taxMatch[2].replace(/,/g, ''));
      if (taxMatch[1]) {
        currency = taxMatch[1];
        taxes = taxAmount;
      } else {
        const allTaxes = upperLine.match(/([\d]+)([A-Z]{2})/g);
        if (allTaxes) {
          taxes = 0;
          for (const t of allTaxes) {
            const [, amount, code] = t.match(/([\d]+)([A-Z]{2})/) || [];
            if (amount && code) {
              const taxAmt = parseFloat(amount);
              taxes += taxAmt;
              taxBreakdown.push({ code, amount: taxAmt });
            }
          }
        } else {
          taxes = taxAmount;
        }
      }
      rawFareLines.push(line);
      continue;
    }

    const totalMatch = upperLine.match(/^TOTAL\s+([A-Z]{3})[\s]*([\d,]+(?:\.\d{2})?)/);
    if (totalMatch) {
      currency = totalMatch[1];
      totalFare = parseFloat(totalMatch[2].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const cnFareMatch = line.match(/ç¥¨åƒ¹[:ï¼š]\s*(?:NT\$|TWD|USD)?\s*([\d,]+)/);
    if (cnFareMatch) {
      baseFare = parseFloat(cnFareMatch[1].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const cnTaxMatch = line.match(/ç¨…é‡‘[:ï¼š]\s*(?:NT\$|TWD|USD)?\s*([\d,]+)/);
    if (cnTaxMatch) {
      taxes = parseFloat(cnTaxMatch[1].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const cnTotalMatch = line.match(/[åˆç¸½]è¨ˆ[:ï¼š]\s*(?:NT\$|TWD|USD)?\s*([\d,]+)/);
    if (cnTotalMatch) {
      totalFare = parseFloat(cnTotalMatch[1].replace(/,/g, ''));
      rawFareLines.push(line);
      continue;
    }

    const grandTotalMatch = upperLine.match(/GRAND\s+TOTAL\s+([A-Z]{3})[\s]*([\d,]+(?:\.\d{2})?)/);
    if (grandTotalMatch) {
      currency = grandTotalMatch[1];
      totalFare = parseFloat(grandTotalMatch[2].replace(/,/g, ''));
      perPassenger = false;
      rawFareLines.push(line);
      continue;
    }
  }

  if (totalFare === null && baseFare === null) {
    return null;
  }

  if (totalFare === null && baseFare !== null) {
    totalFare = baseFare + (taxes || 0);
  }

  if (baseFare === null && totalFare !== null && taxes !== null) {
    baseFare = totalFare - taxes;
  }

  return {
    currency,
    baseFare,
    taxes,
    totalFare: totalFare || 0,
    fareBasis,
    validatingCarrier,
    taxBreakdown,
    perPassenger,
    raw: rawFareLines.join('\n')
  };
}

/**
 * è§£æ Amadeus PNR é›»å ±
 */
export function parseAmadeusPNR(rawPNR: string): ParsedPNR {
  const lines = mergeMultilineEntries(rawPNR);

  logger.log('ğŸ“‹ é–‹å§‹è§£æé›»å ±ï¼Œå…±', lines.length, 'è¡Œ');

  const validation = validateAmadeusPNR(rawPNR);

  const result: ParsedPNR = {
    recordLocator: '',
    passengerNames: [],
    passengers: [],
    segments: [],
    ticketingDeadline: null,
    cancellationDeadline: null,
    specialRequests: [],
    otherInfo: [],
    contactInfo: [],
    validation,
    fareData: null,
    ticketNumbers: [],
    sourceFormat: 'amadeus_pnr',
  };

  for (const line of lines) {
    logger.log('  æª¢æŸ¥è¡Œ:', line);

    // è§£æ Header Line æå– Record Locator
    if (line.startsWith('RP/') && !result.recordLocator) {
      const headerMatch = line.match(/([A-Z0-9]{6})$/);
      if (headerMatch) {
        result.recordLocator = headerMatch[1];
      }
      continue;
    }

    // è§£ææ—…å®¢å§“å
    const passengerLineMatch = line.match(/(\d+)\.([A-Z]+\/[A-Z]+)(?:\(([^)]+)\))?/gi);
    if (passengerLineMatch) {
      for (const match of passengerLineMatch) {
        const passengerMatch = match.match(/(\d+)\.([A-Z]+\/[A-Z]+)(?:\(([^)]+)\))?/i);
        if (passengerMatch) {
          const index = parseInt(passengerMatch[1]);
          const name = passengerMatch[2];
          const extra = passengerMatch[3];

          if (name && !result.passengerNames.includes(name)) {
            result.passengerNames.push(name);
            logger.log('    âœ… æ‰¾åˆ°æ—…å®¢:', name);
          }

          const passenger: PassengerInfo = {
            index,
            name,
            type: 'ADT',
          };

          if (extra) {
            const chdMatch = extra.match(/^CHD\/?(\d{2}[A-Z]{3}\d{2})$/i);
            if (chdMatch) {
              passenger.type = 'CHD';
              passenger.birthDate = chdMatch[1];
              logger.log('    âœ… æ‰¾åˆ°å…’ç«¥:', name, 'ç”Ÿæ—¥:', chdMatch[1]);
            }

            const infMatch = extra.match(/^INF([A-Z]+)\/([A-Z]+)\/(\d{2}[A-Z]{3}\d{2})$/i);
            if (infMatch) {
              passenger.infant = {
                name: `${infMatch[1]}/${infMatch[2]}`,
                birthDate: infMatch[3],
              };
              logger.log('    âœ… æ‰¾åˆ°å¬°å…’:', passenger.infant.name, 'ç”Ÿæ—¥:', infMatch[3], 'éš¨è¡Œæˆäºº:', name);
            }

            if (!passenger.infant) {
              const infMatch2 = extra.match(/^INF\s+([A-Z]+\/[A-Z]+)\s+(\d{2}[A-Z]{3}\d{2})$/i);
              if (infMatch2) {
                passenger.infant = {
                  name: infMatch2[1],
                  birthDate: infMatch2[2],
                };
                logger.log('    âœ… æ‰¾åˆ°å¬°å…’(å‚™ç”¨æ ¼å¼):', passenger.infant.name, 'ç”Ÿæ—¥:', infMatch2[2]);
              }
            }
          }

          result.passengers.push(passenger);
        }
      }
      continue;
    }

    // è§£æèˆªç­è³‡è¨Š
    const segmentMatch = line.match(
      /^(\d+)\s+([A-Z0-9]{2})\s*(\d{1,4})\s+([A-Z])\s+(\d{2}[A-Z]{3})\s+\d?\*?\s*([A-Z]{6})\s+([A-Z]{2})(\d+)\s+(\d{4})\s+(\d{4})/i
    );

    if (segmentMatch) {
      const origin = segmentMatch[6].substring(0, 3);
      const destination = segmentMatch[6].substring(3, 6);

      result.segments.push({
        lineNumber: parseInt(segmentMatch[1]),
        airline: segmentMatch[2],
        flightNumber: segmentMatch[3],
        class: segmentMatch[4],
        departureDate: segmentMatch[5],
        origin: origin,
        destination: destination,
        status: segmentMatch[7],
        passengers: parseInt(segmentMatch[8]),
        departureTime: segmentMatch[9],
        arrivalTime: segmentMatch[10],
      });
      continue;
    }

    // è§£æå‡ºç¥¨æœŸé™ (OPW/OPC æ ¼å¼)
    const opwMatch = line.match(/(?:ON OR BEFORE|BEFORE)\s+(\d{2})([A-Z]{3}):?(\d{4})?/i);
    if (opwMatch) {
      logger.log('    âœ… æ‰¾åˆ° OPW å‡ºç¥¨æœŸé™!', opwMatch);
      const day = opwMatch[1];
      const monthStr = opwMatch[2].toUpperCase();
      const time = opwMatch[3];
      const deadline = parseAmadeusDate(day, monthStr, time);
      logger.log('    ğŸ“… è§£ææ—¥æœŸ:', deadline, time ? `æ™‚é–“: ${time}` : '');
      result.ticketingDeadline = deadline;
      continue;
    }

    // è§£æå‡ºç¥¨æœŸé™ (TK TL æ ¼å¼)
    const tkTlMatch = line.match(/TK\s+TL\s*(\d{2})([A-Z]{3})/i);
    if (tkTlMatch && !result.ticketingDeadline) {
      logger.log('    âœ… æ‰¾åˆ° TK TL å‡ºç¥¨æœŸé™ (å‚™ç”¨)!', tkTlMatch);
      const day = tkTlMatch[1];
      const monthStr = tkTlMatch[2].toUpperCase();
      const deadline = parseAmadeusDate(day, monthStr);
      logger.log('    ğŸ“… è§£ææ—¥æœŸ:', deadline);
      result.ticketingDeadline = deadline;
      continue;
    }

    // è§£æå¬°å…’ SSR
    const ssrInftMatch = line.match(/^\d+\s+SSR\s+INFT\s+([A-Z]{2})\s+([A-Z]{2})(\d+)\s+([A-Z]+\/[A-Z]+)\s+(\d{2}[A-Z]{3}\d{2})(?:\/S(\d+))?(?:\/P(\d+))?/i);
    if (ssrInftMatch) {
      const infantName = ssrInftMatch[4];
      const infantBirthDate = ssrInftMatch[5];
      const segmentNum = ssrInftMatch[6] ? parseInt(ssrInftMatch[6]) : undefined;
      const passengerNum = ssrInftMatch[7] ? parseInt(ssrInftMatch[7]) : undefined;

      result.specialRequests.push({
        code: 'INFT',
        description: `å¬°å…’: ${infantName} (${infantBirthDate})`,
        segments: segmentNum ? [segmentNum] : undefined,
        passenger: passengerNum,
        airline: ssrInftMatch[1],
        raw: line,
        category: SSRCategory.PASSENGER
      });

      if (passengerNum) {
        const passenger = result.passengers.find(p => p.index === passengerNum);
        if (passenger && !passenger.infant) {
          passenger.infant = {
            name: infantName,
            birthDate: infantBirthDate,
          };
        }
      }
      continue;
    }

    // è§£æå…’ç«¥ SSR
    const ssrChldMatch = line.match(/^\d+\s+SSR\s+CHLD\s+([A-Z]{2})\s+([A-Z]{2})(\d+)\s+(\d{2}[A-Z]{3}\d{2})(?:\/P(\d+))?/i);
    if (ssrChldMatch) {
      const childBirthDate = ssrChldMatch[4];
      const passengerNum = ssrChldMatch[5] ? parseInt(ssrChldMatch[5]) : undefined;

      result.specialRequests.push({
        code: 'CHLD',
        description: `å…’ç«¥ (${childBirthDate})`,
        passenger: passengerNum,
        airline: ssrChldMatch[1],
        raw: line,
        category: SSRCategory.PASSENGER
      });

      if (passengerNum) {
        const passenger = result.passengers.find(p => p.index === passengerNum);
        if (passenger) {
          passenger.type = 'CHD';
          passenger.birthDate = childBirthDate;
        }
      }
      continue;
    }

    // æ¨™æº–å¢å¼·å‹ SSR
    if (line.match(/^SR[A-Z]{4}/i)) {
      const ssr = parseEnhancedSSR(line);
      if (ssr) {
        result.specialRequests.push(ssr);
        continue;
      }
    }

    // èˆŠæ ¼å¼ SSR å…¼å®¹
    if (line.match(/^SR\s+/i) || line.match(/^SSR\s+/i)) {
      const rawText = line.replace(/^S{1,2}R\s+/i, '').trim();
      result.specialRequests.push({
        code: 'UNKN',
        description: rawText,
        raw: line,
        category: SSRCategory.OTHER
      });
      continue;
    }

    // è§£æå¢å¼·å‹ OSI
    if (line.match(/^OS[A-Z]{2}\s+/i)) {
      const osi = parseEnhancedOSI(line);
      if (osi) {
        result.otherInfo.push(osi);
        continue;
      }
    }

    // èˆŠæ ¼å¼ OSI å…¼å®¹
    if (line.match(/^OSI\s+/i)) {
      const message = line.replace(/^OSI\s+/i, '').trim();
      result.otherInfo.push({
        airline: 'YY',
        message,
        raw: line,
        category: OSICategory.GENERAL
      });
      continue;
    }

    // è§£æè¯çµ¡è³‡è¨Š
    const contactMatch = line.match(/^AP[EM]?\s+(.+)/i);
    if (contactMatch) {
      result.contactInfo.push(contactMatch[1].trim());
      continue;
    }

    // è§£ææ©Ÿç¥¨è™Ÿç¢¼ FA è¡Œ
    const faMatch = line.match(/(?:^\d+\s+)?FA\s+PAX\s+(\d{3})-?(\d{10,})/i);
    if (faMatch) {
      const ticketNumber = `${faMatch[1]}-${faMatch[2]}`;
      let passengerIndex: number | null = null;
      const pMatch = line.match(/\/P(\d+)\s*$/i);
      if (pMatch) {
        passengerIndex = parseInt(pMatch[1], 10);
      } else {
        const nextLineIndex = lines.indexOf(line) + 1;
        if (nextLineIndex < lines.length) {
          const nextLine = lines[nextLineIndex];
          const nextPMatch = nextLine.match(/\/P(\d+)\s*$/i);
          if (nextPMatch) {
            passengerIndex = parseInt(nextPMatch[1], 10);
          }
        }
      }
      let passengerName = '';
      if (passengerIndex !== null && passengerIndex > 0 && passengerIndex <= result.passengerNames.length) {
        passengerName = result.passengerNames[passengerIndex - 1];
      }
      result.ticketNumbers.push({
        number: ticketNumber,
        passenger: passengerName,
      });
      logger.log('    âœ… æ‰¾åˆ°æ©Ÿç¥¨è™Ÿç¢¼:', ticketNumber, passengerIndex ? `(P${passengerIndex}: ${passengerName})` : '');
      continue;
    }
  }

  // è§£æç¥¨åƒ¹è³‡è¨Š
  result.fareData = parseFareFromTelegram(rawPNR);

  logger.log('ğŸ“‹ Amadeus PNR è§£æå®Œæˆ:', {
    è¨‚ä½ä»£è™Ÿ: result.recordLocator,
    æ—…å®¢æ•¸: result.passengerNames.length,
    æ—…å®¢: result.passengerNames,
    èˆªç­æ•¸: result.segments.length,
  });

  return result;
}
