import { create } from 'zustand';
import { VenturoAPI } from '@/lib/supabase/api';
import { uploadFiles } from '@/lib/supabase/storage';

interface Workspace {
  id: string;
  name: string;
  description?: string;
  icon?: string;
  is_active: boolean;
  created_by?: string;
  created_at?: string;
  updated_at?: string;
}

interface Bulletin {
  id: string;
  workspace_id: string;
  title: string;
  content: string;
  type: 'announcement' | 'notice' | 'event';
  priority: number;
  is_pinned: boolean;
  author_id: string;
  created_at: string;
  updated_at: string;
  author?: {
    chinese_name: string;
    english_name: string;
  };
}

interface Channel {
  id: string;
  workspace_id: string;
  name: string;
  description?: string;
  type: 'public' | 'private' | 'direct';
  created_by?: string;
  created_at: string;
}

interface MessageAttachment {
  url: string;
  path: string;
  fileName: string;
  fileSize: number;
  fileType: string;
}

interface Message {
  id: string;
  channel_id: string;
  author_id: string;
  content: string;
  reactions: Record<string, string[]>;
  attachments?: MessageAttachment[];
  created_at: string;
  edited_at?: string;
  author?: {
    id: string;
    chinese_name: string;
    avatar?: string;
  };
}

interface PersonalCanvas {
  id: string;
  employee_id: string;
  workspace_id: string;
  canvas_number: number;
  title: string;
  type: 'document' | 'tools' | 'custom';
  content: Record<string, any>;
  layout: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface RichDocument {
  id: string;
  canvas_id: string;
  title: string;
  content: string;
  format_data: Record<string, any>;
  tags: string[];
  is_favorite: boolean;
  created_at: string;
  updated_at: string;
}

interface WorkspaceState {
  // State
  workspaces: Workspace[];
  currentWorkspace: Workspace | null;
  bulletins: Bulletin[];
  channels: Channel[];
  messages: Message[];
  personalCanvases: PersonalCanvas[];
  richDocuments: RichDocument[];
  loading: boolean;
  error: string | null;

  // Cache for performance
  channelsCache: Record<string, { data: Channel[], timestamp: number }>;
  messagesCache: Record<string, { data: Message[], timestamp: number }>;

  // Actions
  loadWorkspaces: () => Promise<void>;
  loadWorkspace: (id: string) => Promise<void>;
  setCurrentWorkspace: (workspace: Workspace) => void;

  // Bulletin actions
  loadBulletins: (workspaceId?: string) => Promise<void>;
  createBulletin: (bulletin: Omit<Bulletin, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;
  updateBulletin: (id: string, updates: Partial<Bulletin>) => Promise<void>;
  deleteBulletin: (id: string) => Promise<void>;

  // Channel actions
  loadChannels: (workspaceId?: string) => Promise<void>;
  createChannel: (channel: Omit<Channel, 'id' | 'created_at'>) => Promise<void>;
  updateChannel: (id: string, updates: Partial<Channel>) => Promise<void>;
  deleteChannel: (id: string) => Promise<void>;

  // Message actions
  loadMessages: (channelId: string) => Promise<void>;
  sendMessage: (message: Omit<Message, 'id' | 'created_at' | 'reactions'>, files?: File[]) => Promise<void>;
  updateMessageReactions: (messageId: string, reactions: Record<string, string[]>) => Promise<void>;

  // Personal canvas actions
  loadPersonalCanvases: (employeeId: string, workspaceId?: string) => Promise<void>;
  createPersonalCanvas: (canvas: Omit<PersonalCanvas, 'id' | 'created_at' | 'updated_at'>) => Promise<PersonalCanvas>;
  updatePersonalCanvas: (id: string, updates: Partial<PersonalCanvas>) => Promise<void>;
  deletePersonalCanvas: (id: string) => Promise<void>;

  // Rich document actions
  loadRichDocuments: (canvasId: string) => Promise<void>;
  createRichDocument: (document: Omit<RichDocument, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;
  updateRichDocument: (id: string, updates: Partial<RichDocument>) => Promise<void>;
  deleteRichDocument: (id: string) => Promise<void>;

  // Utility actions
  clearError: () => void;
  setLoading: (loading: boolean) => void;
}

const CACHE_DURATION = 30000; // 30 秒快取

export const useWorkspaceStore = create<WorkspaceState>((set, get) => ({
  // Initial state
  workspaces: [],
  currentWorkspace: null,
  bulletins: [],
  channels: [],
  messages: [],
  personalCanvases: [],
  richDocuments: [],
  loading: false,
  error: null,
  channelsCache: {},
  messagesCache: {},

  // Workspace actions
  loadWorkspaces: async () => {
    console.log('[WorkspaceStore] 📦 本地模式：載入工作空間...');
    set({ loading: true, error: null });
    try {
      // ⚠️ 純本地模式 - 使用測試資料
      const data: Workspace[] = [
        {
          id: 'workspace-001',
          name: '總部辦公室',
          description: 'Venturo 總部工作空間',
          icon: '🏢',
          is_active: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
      ];

      console.log(`[WorkspaceStore] 📦 本地模式：載入完成，找到 ${data.length} 個工作空間`);

      set({
        workspaces: data,
        currentWorkspace: data[0] || null,
        loading: false
      });
    } catch (error) {
      console.error('[WorkspaceStore] 載入工作空間失敗:', error);
      set({ error: '載入工作空間失敗', loading: false });
    }
  },

  loadWorkspace: async (id: string) => {
    try {
      const workspace = await VenturoAPI.readById<Workspace>('workspaces', id);
      if (workspace) {
        set({ currentWorkspace: workspace });
      }
    } catch (error) {
      console.error('Failed to load workspace:', error);
      set({ error: '載入工作空間失敗' });
    }
  },

  setCurrentWorkspace: (workspace: Workspace) => {
    set({ currentWorkspace: workspace });
  },

  // Bulletin actions
  loadBulletins: async (workspaceId?: string) => {
    const { currentWorkspace } = get();
    const targetWorkspaceId = workspaceId || currentWorkspace?.id;

    if (!targetWorkspaceId) return;

    try {
      const data = await VenturoAPI.read<Bulletin>('bulletins', {
        filters: { workspace_id: targetWorkspaceId },
        orderBy: { column: 'priority', ascending: true }
      });
      set({ bulletins: data });
    } catch (error) {
      console.error('Failed to load bulletins:', error);
      set({ error: '載入公告失敗' });
    }
  },

  createBulletin: async (bulletin: Omit<Bulletin, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      const newBulletin = await VenturoAPI.create<Bulletin>('bulletins', bulletin);
      set((state) => ({
        bulletins: [newBulletin, ...state.bulletins]
      }));
    } catch (error) {
      console.error('Failed to create bulletin:', error);
      set({ error: '建立公告失敗' });
    }
  },

  updateBulletin: async (id: string, updates: Partial<Bulletin>) => {
    try {
      const updatedBulletin = await VenturoAPI.update<Bulletin>('bulletins', id, updates);
      set((state) => ({
        bulletins: state.bulletins.map(b =>
          b.id === id ? updatedBulletin : b
        )
      }));
    } catch (error) {
      console.error('Failed to update bulletin:', error);
      set({ error: '更新公告失敗' });
    }
  },

  deleteBulletin: async (id: string) => {
    try {
      await VenturoAPI.delete('bulletins', id);
      set((state) => ({
        bulletins: state.bulletins.filter(b => b.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete bulletin:', error);
      set({ error: '刪除公告失敗' });
    }
  },

  // Channel actions
  loadChannels: async (workspaceId?: string) => {
    const { currentWorkspace, channelsCache } = get();
    const targetWorkspaceId = workspaceId || currentWorkspace?.id;

    if (!targetWorkspaceId) {
      console.log('[WorkspaceStore] 沒有工作空間ID，跳過載入頻道');
      return;
    }

    // 檢查快取
    const cached = channelsCache[targetWorkspaceId];
    const now = Date.now();
    if (cached && (now - cached.timestamp) < CACHE_DURATION) {
      console.log(`[WorkspaceStore] 使用快取的頻道資料 (${cached.data.length} 個)`);
      set({ channels: cached.data });
      return;
    }

    try {
      console.log(`[WorkspaceStore] 開始載入頻道... workspace_id: ${targetWorkspaceId}`);
      const startTime = Date.now();
      const data = await VenturoAPI.read<Channel>('channels', {
        filters: { workspace_id: targetWorkspaceId },
        orderBy: { column: 'created_at', ascending: true }
      });
      const elapsed = Date.now() - startTime;
      console.log(`[WorkspaceStore] 載入頻道完成，耗時 ${elapsed}ms，找到 ${data.length} 個頻道`);

      // 更新快取
      set({
        channels: data,
        channelsCache: {
          ...get().channelsCache,
          [targetWorkspaceId]: { data, timestamp: now }
        }
      });
    } catch (error) {
      console.error('[WorkspaceStore] 載入頻道失敗:', error);
      set({ error: '載入頻道失敗' });
    }
  },

  createChannel: async (channel: Omit<Channel, 'id' | 'created_at'>) => {
    try {
      const newChannel = await VenturoAPI.create<Channel>('channels', channel);
      set((state) => ({
        channels: [...state.channels, newChannel]
      }));
    } catch (error) {
      console.error('Failed to create channel:', error);
      set({ error: '建立頻道失敗' });
    }
  },

  updateChannel: async (id: string, updates: Partial<Channel>) => {
    try {
      const updatedChannel = await VenturoAPI.update<Channel>('channels', id, updates);
      set((state) => ({
        channels: state.channels.map(c =>
          c.id === id ? updatedChannel : c
        )
      }));
    } catch (error) {
      console.error('Failed to update channel:', error);
      set({ error: '更新頻道失敗' });
      throw error;
    }
  },

  deleteChannel: async (id: string) => {
    try {
      await VenturoAPI.delete('channels', id);
      set((state) => ({
        channels: state.channels.filter(c => c.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete channel:', error);
      set({ error: '刪除頻道失敗' });
      throw error;
    }
  },

  // Message actions
  loadMessages: async (channelId: string) => {
    try {
      console.log(`[WorkspaceStore] 開始載入訊息... channel_id: ${channelId}`);
      const startTime = Date.now();

      // 先嘗試載入訊息（訊息可能已經包含 author 欄位）
      let data = await VenturoAPI.read<Message>('messages', {
        filters: { channel_id: channelId },
        orderBy: { column: 'created_at', ascending: true }
      });

      // 如果訊息沒有 author 資訊，則從 users 表補充
      const messagesWithoutAuthor = data.filter(m => !m.author || !m.author.chinese_name);
      if (messagesWithoutAuthor.length > 0) {
        console.log(`[WorkspaceStore] 發現 ${messagesWithoutAuthor.length} 則訊息缺少作者資訊，正在從 users 表補充...`);

        // 取得所有缺少資訊的 author_id
        const authorIds = [...new Set(messagesWithoutAuthor.map(m => m.author_id).filter(Boolean))];

        if (authorIds.length > 0) {
          // 批次查詢用戶資訊
          const users = await VenturoAPI.read<any>('users', {
            filters: { id: authorIds }
          });

          // 建立用戶 map
          const userMap = new Map(users.map(u => [u.id, u]));

          // 補充作者資訊
          data = data.map(message => {
            if (!message.author || !message.author.chinese_name) {
              const user = userMap.get(message.author_id);
              if (user) {
                return {
                  ...message,
                  author: {
                    id: user.id,
                    chinese_name: user.chineseName || user.chinese_name,
                    avatar: user.avatar
                  }
                };
              }
            }
            return message;
          });
        }
      }

      const elapsed = Date.now() - startTime;
      console.log(`[WorkspaceStore] 載入訊息完成，耗時 ${elapsed}ms，找到 ${data.length} 則訊息`);
      set({ messages: data });
    } catch (error) {
      console.error('[WorkspaceStore] 載入訊息失敗:', error);
      set({ error: '載入訊息失敗' });
    }
  },

  sendMessage: async (message: Omit<Message, 'id' | 'created_at' | 'reactions'>, files?: File[]) => {
    // 生成臨時 ID 用於樂觀更新
    const tempId = `temp_${Date.now()}`;

    // 樂觀更新：立即將訊息加到畫面
    const optimisticMessage: Message = {
      id: tempId,
      ...message,
      reactions: {},
      created_at: new Date().toISOString(),
      attachments: []
    };

    set((state) => ({
      messages: [...state.messages, optimisticMessage]
    }));

    try {
      let attachments: MessageAttachment[] = [];

      // 如果有附件，先上傳檔案
      if (files && files.length > 0) {
        const uploadResults = await uploadFiles(
          files,
          'workspace-files',
          `channels/${message.channel_id}`
        );

        attachments = uploadResults.map((result, index) => ({
          url: result.url,
          path: result.path,
          fileName: result.fileName,
          fileSize: files[index].size,
          fileType: files[index].type
        }));
      }

      // 發送訊息到資料庫
      const createdMessage = await VenturoAPI.create<Message>('messages', {
        ...message,
        reactions: {},
        attachments
      });

      // 用真實訊息替換臨時訊息
      set((state) => ({
        messages: state.messages.map(m =>
          m.id === tempId ? { ...createdMessage, author: message.author } : m
        )
      }));
    } catch (error) {
      console.error('Failed to send message:', error);
      // 發送失敗，移除樂觀更新的訊息
      set((state) => ({
        messages: state.messages.filter(m => m.id !== tempId),
        error: '發送訊息失敗'
      }));
      throw error;
    }
  },

  updateMessageReactions: async (messageId: string, reactions: Record<string, string[]>) => {
    try {
      await VenturoAPI.update<Message>('messages', messageId, { reactions });
      set((state) => ({
        messages: state.messages.map(m =>
          m.id === messageId ? { ...m, reactions } : m
        )
      }));
    } catch (error) {
      console.error('Failed to update message reactions:', error);
      set({ error: '更新反應失敗' });
    }
  },

  // Personal canvas actions
  loadPersonalCanvases: async (employeeId: string, workspaceId?: string) => {
    const { currentWorkspace } = get();
    const targetWorkspaceId = workspaceId || currentWorkspace?.id;

    const filters: any = { employee_id: employeeId };
    if (targetWorkspaceId) {
      filters.workspace_id = targetWorkspaceId;
    }

    try {
      const data = await VenturoAPI.read<PersonalCanvas>('personal_canvases', {
        filters,
        orderBy: { column: 'canvas_number', ascending: true }
      });
      set({ personalCanvases: data });
    } catch (error) {
      console.error('Failed to load personal canvases:', error);
      set({ error: '載入個人畫布失敗' });
    }
  },

  createPersonalCanvas: async (canvas: Omit<PersonalCanvas, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      // 暫時使用本地模擬資料，直到 personal_canvases 表格建立
      const id = Date.now().toString();
      const now = new Date().toISOString();
      const newCanvas: PersonalCanvas = {
        ...canvas,
        id,
        created_at: now,
        updated_at: now
      };

      set((state) => ({
        personalCanvases: [...state.personalCanvases, newCanvas]
      }));

      return newCanvas;
    } catch (error) {
      console.error('Failed to create personal canvas:', error);
      set({ error: '建立個人畫布失敗' });
      throw error;
    }
  },

  updatePersonalCanvas: async (id: string, updates: Partial<PersonalCanvas>) => {
    try {
      const updatedCanvas = await VenturoAPI.update<PersonalCanvas>('personal_canvases', id, updates);
      set((state) => ({
        personalCanvases: state.personalCanvases.map(c =>
          c.id === id ? updatedCanvas : c
        )
      }));
    } catch (error) {
      console.error('Failed to update personal canvas:', error);
      set({ error: '更新個人畫布失敗' });
    }
  },

  deletePersonalCanvas: async (id: string) => {
    try {
      await VenturoAPI.delete('personal_canvases', id);
      set((state) => ({
        personalCanvases: state.personalCanvases.filter(c => c.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete personal canvas:', error);
      set({ error: '刪除個人畫布失敗' });
    }
  },

  // Rich document actions
  loadRichDocuments: async (canvasId: string) => {
    try {
      const data = await VenturoAPI.read<RichDocument>('rich_documents', {
        filters: { canvas_id: canvasId },
        orderBy: { column: 'is_favorite', ascending: false }
      });
      set({ richDocuments: data });
    } catch (error) {
      console.error('Failed to load rich documents:', error);
      set({ error: '載入文件失敗' });
    }
  },

  createRichDocument: async (document: Omit<RichDocument, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      const newDocument = await VenturoAPI.create<RichDocument>('rich_documents', {
        ...document,
        format_data: document.format_data || {}
      });
      set((state) => ({
        richDocuments: [newDocument, ...state.richDocuments]
      }));
    } catch (error) {
      console.error('Failed to create rich document:', error);
      set({ error: '建立文件失敗' });
    }
  },

  updateRichDocument: async (id: string, updates: Partial<RichDocument>) => {
    try {
      const updatedDocument = await VenturoAPI.update<RichDocument>('rich_documents', id, updates);
      set((state) => ({
        richDocuments: state.richDocuments.map(d =>
          d.id === id ? updatedDocument : d
        )
      }));
    } catch (error) {
      console.error('Failed to update rich document:', error);
      set({ error: '更新文件失敗' });
    }
  },

  deleteRichDocument: async (id: string) => {
    try {
      await VenturoAPI.delete('rich_documents', id);
      set((state) => ({
        richDocuments: state.richDocuments.filter(d => d.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete rich document:', error);
      set({ error: '刪除文件失敗' });
    }
  },

  // Utility actions
  clearError: () => set({ error: null }),
  setLoading: (loading: boolean) => set({ loading }),
}));