import { create } from 'zustand';
import { VenturoAPI } from '@/lib/supabase/api';
import { uploadFiles } from '@/lib/supabase/storage';

interface Workspace {
  id: string;
  name: string;
  description?: string;
  icon?: string;
  is_active: boolean;
  created_by?: string;
  created_at?: string;
  updated_at?: string;
}

interface Bulletin {
  id: string;
  workspace_id: string;
  title: string;
  content: string;
  type: 'announcement' | 'notice' | 'event';
  priority: number;
  is_pinned: boolean;
  author_id: string;
  created_at: string;
  updated_at: string;
  author?: {
    chinese_name: string;
    english_name: string;
  };
}

interface Channel {
  id: string;
  workspace_id: string;
  name: string;
  description?: string;
  type: 'public' | 'private' | 'direct';
  created_by?: string;
  created_at: string;
}

interface MessageAttachment {
  url: string;
  path: string;
  fileName: string;
  fileSize: number;
  fileType: string;
}

interface Message {
  id: string;
  channel_id: string;
  author_id: string;
  content: string;
  reactions: Record<string, string[]>;
  attachments?: MessageAttachment[];
  created_at: string;
  edited_at?: string;
  author?: {
    id: string;
    chinese_name: string;
    avatar?: string;
  };
}

interface PersonalCanvas {
  id: string;
  employee_id: string;
  workspace_id: string;
  canvas_number: number;
  title: string;
  type: 'document' | 'tools' | 'custom';
  content: Record<string, any>;
  layout: Record<string, any>;
  created_at: string;
  updated_at: string;
}

interface RichDocument {
  id: string;
  canvas_id: string;
  title: string;
  content: string;
  format_data: Record<string, any>;
  tags: string[];
  is_favorite: boolean;
  created_at: string;
  updated_at: string;
}

interface WorkspaceState {
  // State
  workspaces: Workspace[];
  currentWorkspace: Workspace | null;
  bulletins: Bulletin[];
  channels: Channel[];
  messages: Message[];
  personalCanvases: PersonalCanvas[];
  richDocuments: RichDocument[];
  loading: boolean;
  error: string | null;

  // Cache for performance
  channelsCache: Record<string, { data: Channel[], timestamp: number }>;
  messagesCache: Record<string, { data: Message[], timestamp: number }>;

  // Actions
  loadWorkspaces: () => Promise<void>;
  loadWorkspace: (id: string) => Promise<void>;
  setCurrentWorkspace: (workspace: Workspace) => void;

  // Bulletin actions
  loadBulletins: (workspaceId?: string) => Promise<void>;
  createBulletin: (bulletin: Omit<Bulletin, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;
  updateBulletin: (id: string, updates: Partial<Bulletin>) => Promise<void>;
  deleteBulletin: (id: string) => Promise<void>;

  // Channel actions
  loadChannels: (workspaceId?: string) => Promise<void>;
  createChannel: (channel: Omit<Channel, 'id' | 'created_at'>) => Promise<void>;
  updateChannel: (id: string, updates: Partial<Channel>) => Promise<void>;
  deleteChannel: (id: string) => Promise<void>;

  // Message actions
  loadMessages: (channelId: string) => Promise<void>;
  sendMessage: (message: Omit<Message, 'id' | 'created_at' | 'reactions'>, files?: File[]) => Promise<void>;
  updateMessageReactions: (messageId: string, reactions: Record<string, string[]>) => Promise<void>;

  // Personal canvas actions
  loadPersonalCanvases: (employeeId: string, workspaceId?: string) => Promise<void>;
  createPersonalCanvas: (canvas: Omit<PersonalCanvas, 'id' | 'created_at' | 'updated_at'>) => Promise<PersonalCanvas>;
  updatePersonalCanvas: (id: string, updates: Partial<PersonalCanvas>) => Promise<void>;
  deletePersonalCanvas: (id: string) => Promise<void>;

  // Rich document actions
  loadRichDocuments: (canvasId: string) => Promise<void>;
  createRichDocument: (document: Omit<RichDocument, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;
  updateRichDocument: (id: string, updates: Partial<RichDocument>) => Promise<void>;
  deleteRichDocument: (id: string) => Promise<void>;

  // Utility actions
  clearError: () => void;
  setLoading: (loading: boolean) => void;
}

const CACHE_DURATION = 30000; // 30 ç§’å¿«å–

export const useWorkspaceStore = create<WorkspaceState>((set, get) => ({
  // Initial state
  workspaces: [],
  currentWorkspace: null,
  bulletins: [],
  channels: [],
  messages: [],
  personalCanvases: [],
  richDocuments: [],
  loading: false,
  error: null,
  channelsCache: {},
  messagesCache: {},

  // Workspace actions
  loadWorkspaces: async () => {
    console.log('[WorkspaceStore] ğŸ“¦ æœ¬åœ°æ¨¡å¼ï¼šè¼‰å…¥å·¥ä½œç©ºé–“...');
    set({ loading: true, error: null });
    try {
      // âš ï¸ ç´”æœ¬åœ°æ¨¡å¼ - ä½¿ç”¨æ¸¬è©¦è³‡æ–™
      const data: Workspace[] = [
        {
          id: 'workspace-001',
          name: 'ç¸½éƒ¨è¾¦å…¬å®¤',
          description: 'Venturo ç¸½éƒ¨å·¥ä½œç©ºé–“',
          icon: 'ğŸ¢',
          is_active: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
      ];

      console.log(`[WorkspaceStore] ğŸ“¦ æœ¬åœ°æ¨¡å¼ï¼šè¼‰å…¥å®Œæˆï¼Œæ‰¾åˆ° ${data.length} å€‹å·¥ä½œç©ºé–“`);

      set({
        workspaces: data,
        currentWorkspace: data[0] || null,
        loading: false
      });
    } catch (error) {
      console.error('[WorkspaceStore] è¼‰å…¥å·¥ä½œç©ºé–“å¤±æ•—:', error);
      set({ error: 'è¼‰å…¥å·¥ä½œç©ºé–“å¤±æ•—', loading: false });
    }
  },

  loadWorkspace: async (id: string) => {
    try {
      const workspace = await VenturoAPI.readById<Workspace>('workspaces', id);
      if (workspace) {
        set({ currentWorkspace: workspace });
      }
    } catch (error) {
      console.error('Failed to load workspace:', error);
      set({ error: 'è¼‰å…¥å·¥ä½œç©ºé–“å¤±æ•—' });
    }
  },

  setCurrentWorkspace: (workspace: Workspace) => {
    set({ currentWorkspace: workspace });
  },

  // Bulletin actions
  loadBulletins: async (workspaceId?: string) => {
    const { currentWorkspace } = get();
    const targetWorkspaceId = workspaceId || currentWorkspace?.id;

    if (!targetWorkspaceId) return;

    try {
      const data = await VenturoAPI.read<Bulletin>('bulletins', {
        filters: { workspace_id: targetWorkspaceId },
        orderBy: { column: 'priority', ascending: true }
      });
      set({ bulletins: data });
    } catch (error) {
      console.error('Failed to load bulletins:', error);
      set({ error: 'è¼‰å…¥å…¬å‘Šå¤±æ•—' });
    }
  },

  createBulletin: async (bulletin: Omit<Bulletin, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      const newBulletin = await VenturoAPI.create<Bulletin>('bulletins', bulletin);
      set((state) => ({
        bulletins: [newBulletin, ...state.bulletins]
      }));
    } catch (error) {
      console.error('Failed to create bulletin:', error);
      set({ error: 'å»ºç«‹å…¬å‘Šå¤±æ•—' });
    }
  },

  updateBulletin: async (id: string, updates: Partial<Bulletin>) => {
    try {
      const updatedBulletin = await VenturoAPI.update<Bulletin>('bulletins', id, updates);
      set((state) => ({
        bulletins: state.bulletins.map(b =>
          b.id === id ? updatedBulletin : b
        )
      }));
    } catch (error) {
      console.error('Failed to update bulletin:', error);
      set({ error: 'æ›´æ–°å…¬å‘Šå¤±æ•—' });
    }
  },

  deleteBulletin: async (id: string) => {
    try {
      await VenturoAPI.delete('bulletins', id);
      set((state) => ({
        bulletins: state.bulletins.filter(b => b.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete bulletin:', error);
      set({ error: 'åˆªé™¤å…¬å‘Šå¤±æ•—' });
    }
  },

  // Channel actions
  loadChannels: async (workspaceId?: string) => {
    const { currentWorkspace, channelsCache } = get();
    const targetWorkspaceId = workspaceId || currentWorkspace?.id;

    if (!targetWorkspaceId) {
      console.log('[WorkspaceStore] æ²’æœ‰å·¥ä½œç©ºé–“IDï¼Œè·³éè¼‰å…¥é »é“');
      return;
    }

    // æª¢æŸ¥å¿«å–
    const cached = channelsCache[targetWorkspaceId];
    const now = Date.now();
    if (cached && (now - cached.timestamp) < CACHE_DURATION) {
      console.log(`[WorkspaceStore] ä½¿ç”¨å¿«å–çš„é »é“è³‡æ–™ (${cached.data.length} å€‹)`);
      set({ channels: cached.data });
      return;
    }

    try {
      console.log(`[WorkspaceStore] é–‹å§‹è¼‰å…¥é »é“... workspace_id: ${targetWorkspaceId}`);
      const startTime = Date.now();
      const data = await VenturoAPI.read<Channel>('channels', {
        filters: { workspace_id: targetWorkspaceId },
        orderBy: { column: 'created_at', ascending: true }
      });
      const elapsed = Date.now() - startTime;
      console.log(`[WorkspaceStore] è¼‰å…¥é »é“å®Œæˆï¼Œè€—æ™‚ ${elapsed}msï¼Œæ‰¾åˆ° ${data.length} å€‹é »é“`);

      // æ›´æ–°å¿«å–
      set({
        channels: data,
        channelsCache: {
          ...get().channelsCache,
          [targetWorkspaceId]: { data, timestamp: now }
        }
      });
    } catch (error) {
      console.error('[WorkspaceStore] è¼‰å…¥é »é“å¤±æ•—:', error);
      set({ error: 'è¼‰å…¥é »é“å¤±æ•—' });
    }
  },

  createChannel: async (channel: Omit<Channel, 'id' | 'created_at'>) => {
    try {
      const newChannel = await VenturoAPI.create<Channel>('channels', channel);
      set((state) => ({
        channels: [...state.channels, newChannel]
      }));
    } catch (error) {
      console.error('Failed to create channel:', error);
      set({ error: 'å»ºç«‹é »é“å¤±æ•—' });
    }
  },

  updateChannel: async (id: string, updates: Partial<Channel>) => {
    try {
      const updatedChannel = await VenturoAPI.update<Channel>('channels', id, updates);
      set((state) => ({
        channels: state.channels.map(c =>
          c.id === id ? updatedChannel : c
        )
      }));
    } catch (error) {
      console.error('Failed to update channel:', error);
      set({ error: 'æ›´æ–°é »é“å¤±æ•—' });
      throw error;
    }
  },

  deleteChannel: async (id: string) => {
    try {
      await VenturoAPI.delete('channels', id);
      set((state) => ({
        channels: state.channels.filter(c => c.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete channel:', error);
      set({ error: 'åˆªé™¤é »é“å¤±æ•—' });
      throw error;
    }
  },

  // Message actions
  loadMessages: async (channelId: string) => {
    try {
      console.log(`[WorkspaceStore] é–‹å§‹è¼‰å…¥è¨Šæ¯... channel_id: ${channelId}`);
      const startTime = Date.now();

      // å…ˆå˜—è©¦è¼‰å…¥è¨Šæ¯ï¼ˆè¨Šæ¯å¯èƒ½å·²ç¶“åŒ…å« author æ¬„ä½ï¼‰
      let data = await VenturoAPI.read<Message>('messages', {
        filters: { channel_id: channelId },
        orderBy: { column: 'created_at', ascending: true }
      });

      // å¦‚æœè¨Šæ¯æ²’æœ‰ author è³‡è¨Šï¼Œå‰‡å¾ users è¡¨è£œå……
      const messagesWithoutAuthor = data.filter(m => !m.author || !m.author.chinese_name);
      if (messagesWithoutAuthor.length > 0) {
        console.log(`[WorkspaceStore] ç™¼ç¾ ${messagesWithoutAuthor.length} å‰‡è¨Šæ¯ç¼ºå°‘ä½œè€…è³‡è¨Šï¼Œæ­£åœ¨å¾ users è¡¨è£œå……...`);

        // å–å¾—æ‰€æœ‰ç¼ºå°‘è³‡è¨Šçš„ author_id
        const authorIds = [...new Set(messagesWithoutAuthor.map(m => m.author_id).filter(Boolean))];

        if (authorIds.length > 0) {
          // æ‰¹æ¬¡æŸ¥è©¢ç”¨æˆ¶è³‡è¨Š
          const users = await VenturoAPI.read<any>('users', {
            filters: { id: authorIds }
          });

          // å»ºç«‹ç”¨æˆ¶ map
          const userMap = new Map(users.map(u => [u.id, u]));

          // è£œå……ä½œè€…è³‡è¨Š
          data = data.map(message => {
            if (!message.author || !message.author.chinese_name) {
              const user = userMap.get(message.author_id);
              if (user) {
                return {
                  ...message,
                  author: {
                    id: user.id,
                    chinese_name: user.chineseName || user.chinese_name,
                    avatar: user.avatar
                  }
                };
              }
            }
            return message;
          });
        }
      }

      const elapsed = Date.now() - startTime;
      console.log(`[WorkspaceStore] è¼‰å…¥è¨Šæ¯å®Œæˆï¼Œè€—æ™‚ ${elapsed}msï¼Œæ‰¾åˆ° ${data.length} å‰‡è¨Šæ¯`);
      set({ messages: data });
    } catch (error) {
      console.error('[WorkspaceStore] è¼‰å…¥è¨Šæ¯å¤±æ•—:', error);
      set({ error: 'è¼‰å…¥è¨Šæ¯å¤±æ•—' });
    }
  },

  sendMessage: async (message: Omit<Message, 'id' | 'created_at' | 'reactions'>, files?: File[]) => {
    // ç”Ÿæˆè‡¨æ™‚ ID ç”¨æ–¼æ¨‚è§€æ›´æ–°
    const tempId = `temp_${Date.now()}`;

    // æ¨‚è§€æ›´æ–°ï¼šç«‹å³å°‡è¨Šæ¯åŠ åˆ°ç•«é¢
    const optimisticMessage: Message = {
      id: tempId,
      ...message,
      reactions: {},
      created_at: new Date().toISOString(),
      attachments: []
    };

    set((state) => ({
      messages: [...state.messages, optimisticMessage]
    }));

    try {
      let attachments: MessageAttachment[] = [];

      // å¦‚æœæœ‰é™„ä»¶ï¼Œå…ˆä¸Šå‚³æª”æ¡ˆ
      if (files && files.length > 0) {
        const uploadResults = await uploadFiles(
          files,
          'workspace-files',
          `channels/${message.channel_id}`
        );

        attachments = uploadResults.map((result, index) => ({
          url: result.url,
          path: result.path,
          fileName: result.fileName,
          fileSize: files[index].size,
          fileType: files[index].type
        }));
      }

      // ç™¼é€è¨Šæ¯åˆ°è³‡æ–™åº«
      const createdMessage = await VenturoAPI.create<Message>('messages', {
        ...message,
        reactions: {},
        attachments
      });

      // ç”¨çœŸå¯¦è¨Šæ¯æ›¿æ›è‡¨æ™‚è¨Šæ¯
      set((state) => ({
        messages: state.messages.map(m =>
          m.id === tempId ? { ...createdMessage, author: message.author } : m
        )
      }));
    } catch (error) {
      console.error('Failed to send message:', error);
      // ç™¼é€å¤±æ•—ï¼Œç§»é™¤æ¨‚è§€æ›´æ–°çš„è¨Šæ¯
      set((state) => ({
        messages: state.messages.filter(m => m.id !== tempId),
        error: 'ç™¼é€è¨Šæ¯å¤±æ•—'
      }));
      throw error;
    }
  },

  updateMessageReactions: async (messageId: string, reactions: Record<string, string[]>) => {
    try {
      await VenturoAPI.update<Message>('messages', messageId, { reactions });
      set((state) => ({
        messages: state.messages.map(m =>
          m.id === messageId ? { ...m, reactions } : m
        )
      }));
    } catch (error) {
      console.error('Failed to update message reactions:', error);
      set({ error: 'æ›´æ–°åæ‡‰å¤±æ•—' });
    }
  },

  // Personal canvas actions
  loadPersonalCanvases: async (employeeId: string, workspaceId?: string) => {
    const { currentWorkspace } = get();
    const targetWorkspaceId = workspaceId || currentWorkspace?.id;

    const filters: any = { employee_id: employeeId };
    if (targetWorkspaceId) {
      filters.workspace_id = targetWorkspaceId;
    }

    try {
      const data = await VenturoAPI.read<PersonalCanvas>('personal_canvases', {
        filters,
        orderBy: { column: 'canvas_number', ascending: true }
      });
      set({ personalCanvases: data });
    } catch (error) {
      console.error('Failed to load personal canvases:', error);
      set({ error: 'è¼‰å…¥å€‹äººç•«å¸ƒå¤±æ•—' });
    }
  },

  createPersonalCanvas: async (canvas: Omit<PersonalCanvas, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      // æš«æ™‚ä½¿ç”¨æœ¬åœ°æ¨¡æ“¬è³‡æ–™ï¼Œç›´åˆ° personal_canvases è¡¨æ ¼å»ºç«‹
      const id = Date.now().toString();
      const now = new Date().toISOString();
      const newCanvas: PersonalCanvas = {
        ...canvas,
        id,
        created_at: now,
        updated_at: now
      };

      set((state) => ({
        personalCanvases: [...state.personalCanvases, newCanvas]
      }));

      return newCanvas;
    } catch (error) {
      console.error('Failed to create personal canvas:', error);
      set({ error: 'å»ºç«‹å€‹äººç•«å¸ƒå¤±æ•—' });
      throw error;
    }
  },

  updatePersonalCanvas: async (id: string, updates: Partial<PersonalCanvas>) => {
    try {
      const updatedCanvas = await VenturoAPI.update<PersonalCanvas>('personal_canvases', id, updates);
      set((state) => ({
        personalCanvases: state.personalCanvases.map(c =>
          c.id === id ? updatedCanvas : c
        )
      }));
    } catch (error) {
      console.error('Failed to update personal canvas:', error);
      set({ error: 'æ›´æ–°å€‹äººç•«å¸ƒå¤±æ•—' });
    }
  },

  deletePersonalCanvas: async (id: string) => {
    try {
      await VenturoAPI.delete('personal_canvases', id);
      set((state) => ({
        personalCanvases: state.personalCanvases.filter(c => c.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete personal canvas:', error);
      set({ error: 'åˆªé™¤å€‹äººç•«å¸ƒå¤±æ•—' });
    }
  },

  // Rich document actions
  loadRichDocuments: async (canvasId: string) => {
    try {
      const data = await VenturoAPI.read<RichDocument>('rich_documents', {
        filters: { canvas_id: canvasId },
        orderBy: { column: 'is_favorite', ascending: false }
      });
      set({ richDocuments: data });
    } catch (error) {
      console.error('Failed to load rich documents:', error);
      set({ error: 'è¼‰å…¥æ–‡ä»¶å¤±æ•—' });
    }
  },

  createRichDocument: async (document: Omit<RichDocument, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      const newDocument = await VenturoAPI.create<RichDocument>('rich_documents', {
        ...document,
        format_data: document.format_data || {}
      });
      set((state) => ({
        richDocuments: [newDocument, ...state.richDocuments]
      }));
    } catch (error) {
      console.error('Failed to create rich document:', error);
      set({ error: 'å»ºç«‹æ–‡ä»¶å¤±æ•—' });
    }
  },

  updateRichDocument: async (id: string, updates: Partial<RichDocument>) => {
    try {
      const updatedDocument = await VenturoAPI.update<RichDocument>('rich_documents', id, updates);
      set((state) => ({
        richDocuments: state.richDocuments.map(d =>
          d.id === id ? updatedDocument : d
        )
      }));
    } catch (error) {
      console.error('Failed to update rich document:', error);
      set({ error: 'æ›´æ–°æ–‡ä»¶å¤±æ•—' });
    }
  },

  deleteRichDocument: async (id: string) => {
    try {
      await VenturoAPI.delete('rich_documents', id);
      set((state) => ({
        richDocuments: state.richDocuments.filter(d => d.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete rich document:', error);
      set({ error: 'åˆªé™¤æ–‡ä»¶å¤±æ•—' });
    }
  },

  // Utility actions
  clearError: () => set({ error: null }),
  setLoading: (loading: boolean) => set({ loading }),
}));