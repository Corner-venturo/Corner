import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { supabase } from '@/lib/supabase/client';
import { v4 as uuidv4 } from 'uuid';
import { localDB } from '@/lib/db';



interface Workspace {
  id: string;
  name: string;
  description?: string;
  icon?: string;
  is_active: boolean;
  created_by?: string;
  created_at?: string;
  updated_at?: string;
}

interface Bulletin {
  id: string;
  workspace_id: string;
  title: string;
  content: string;
  type: 'announcement' | 'notice' | 'event';
  priority: number;
  is_pinned: boolean;
  author_id: string;
  created_at: string;
  updated_at: string;
  author?: {
    display_name: string;
    english_name: string;
  };
}

export interface Channel {
  id: string;
  workspace_id: string;
  name: string;
  description?: string;
  type: 'public' | 'private' | 'direct';
  created_by?: string;
  created_at: string;
  is_favorite?: boolean;
  group_id?: string;
  tour_id?: string;
}

export interface ChannelGroup {
  id: string;
  workspace_id: string;
  name: string;
  is_collapsed: boolean;
  order: number;
  created_at?: string;
}

interface AdvanceList {
  id: string;
  channel_id: string;
  author_id: string;
  items: Array<{
    id: string;
    name: string;
    amount: number;
    payer_id?: string;
    payer_name?: string;
    note?: string;
  }>;
  created_at: string;
  author?: {
    id: string;
    display_name: string;
    avatar?: string;
  };
}

interface Message {
  id: string;
  channel_id: string;
  author_id: string;
  content: string;
  reactions: Record<string, string[]>;
  attachments?: any[];
  created_at: string;
  edited_at?: string;
  author?: {
    id: string;
    display_name: string;
    avatar?: string;
  };
}

export interface AdvanceItem {
  id: string;
  name: string;
  description: string;
  amount: number;
  advance_person: string;
  status: 'pending' | 'processing' | 'completed' | 'cancelled';
  payment_request_id?: string;
  processed_by?: string;
  processed_at?: string;
}

export interface AdvanceList {
  id: string;
  channel_id: string;
  items: AdvanceItem[];
  created_by: string;
  created_at: string;
  author?: {
    id: string;
    display_name: string;
    avatar?: string;
  };
}

export interface SharedOrderList {
  id: string;
  channel_id: string;
  orders: Array<{
    id: string;
    order_number: string;
    contact_person: string;
    total_amount: number;
    paid_amount: number;
    gap: number;
    collection_rate: number;
    invoice_status?: 'not_invoiced' | 'invoiced';
    receipt_status?: 'not_received' | 'received';
  }>;
  created_by: string;
  created_at: string;
  author?: {
    id: string;
    display_name: string;
    avatar?: string;
  };
}

interface WorkspaceState {
  workspaces: Workspace[];
  currentWorkspace: Workspace | null;
  bulletins: Bulletin[];
  channels: Channel[];
  channelGroups: ChannelGroup[];
  selectedChannel: Channel | null;  // ‚ú® Êñ∞Â¢ûÔºöÁï∂ÂâçÈÅ∏ÊìáÁöÑÈ†ªÈÅì
  currentChannel: Channel | null;   // ‚ú® Êñ∞Â¢ûÔºöÁï∂ÂâçÈ†ªÈÅìÔºàËàá selectedChannel ÂêåÊ≠•Ôºâ
  messages: Message[];
  advanceLists: AdvanceList[];
  sharedOrderLists: SharedOrderList[];
  loading: boolean;
  error: string | null;
  searchQuery: string;
  channelFilter: 'all' | 'starred' | 'unread' | 'muted';

  loadWorkspaces: () => Promise<void>;
  setCurrentWorkspace: (workspace: Workspace) => void;

  loadBulletins: (workspaceId?: string) => Promise<void>;
  createBulletin: (bulletin: Omit<Bulletin, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;
  updateBulletin: (id: string, updates: Partial<Bulletin>) => Promise<void>;
  deleteBulletin: (id: string) => Promise<void>;

  loadChannels: (workspaceId?: string) => Promise<void>;
  createChannel: (channel: Omit<Channel, 'id' | 'created_at'>) => Promise<void>;
  updateChannel: (id: string, updates: Partial<Channel>) => Promise<void>;
  deleteChannel: (id: string) => Promise<void>;
  toggleChannelFavorite: (id: string) => void;

  createChannelGroup: (group: Omit<ChannelGroup, 'id' | 'created_at'>) => void;
  toggleGroupCollapse: (id: string) => void;

  setSearchQuery: (query: string) => void;
  setChannelFilter: (filter: 'all' | 'starred' | 'unread' | 'muted') => void;

  selectChannel: (channel: Channel | null) => Promise<void>;  // ‚ú® Êñ∞Â¢ûÔºöÂàáÊèõÈ†ªÈÅì
  loadMessages: (channelId: string) => Promise<void>;
  sendMessage: (message: Omit<Message, 'id' | 'created_at' | 'reactions'>) => Promise<void>;
  updateMessageReactions: (messageId: string, reactions: Record<string, string[]>) => Promise<void>;
  deleteMessage: (messageId: string) => Promise<void>;
  softDeleteMessage: (messageId: string) => Promise<void>;

  shareAdvanceList: (channelId: string, items: Omit<AdvanceItem, 'id' | 'status'>[], currentUserId: string) => Promise<void>;
  processAdvanceItem: (listId: string, itemId: string, paymentRequestId: string, processedBy: string) => Promise<void>;
  updateAdvanceStatus: (listId: string, itemId: string, status: AdvanceItem['status']) => Promise<void>;
  loadAdvanceLists: (channelId: string) => Promise<void>;
  deleteAdvanceList: (listId: string) => Promise<void>;

  shareOrderList: (channelId: string, orderIds: string[], currentUserId: string) => Promise<void>;
  updateOrderReceiptStatus: (listId: string, orderId: string, receiptId: string) => Promise<void>;
  loadSharedOrderLists: (channelId: string) => Promise<void>;

  clearError: () => void;
}

export const useWorkspaceStore = create<WorkspaceState>()(
  persist(
    (set, get) => ({
      workspaces: [],
      currentWorkspace: null,
      bulletins: [],
      channels: [],
      channelGroups: [],
      selectedChannel: null,  // ‚ú® Êñ∞Â¢û
      currentChannel: null,   // ‚ú® Êñ∞Â¢û
      messages: [],
      advanceLists: [],
      sharedOrderLists: [],
      loading: false,
      error: null,
      searchQuery: '',
      channelFilter: 'all',

      loadWorkspaces: async () => {
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        set({ loading: true });

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂæû Supabase ËºâÂÖ•
            const { data, error } = await supabase
              .from('workspaces')
              .select('*')
              .eq('is_active', true)
              .order('created_at', { ascending: true });

            if (error) throw error;

            console.log('‚úÖ Âæû Supabase ËºâÂÖ•Â∑•‰ΩúÁ©∫Èñì:', data);

            set({
              workspaces: data || [],
              currentWorkspace: data?.[0] || null,
              loading: false
            });
          } else {
            // üì¥ Èõ¢Á∑öÔºö‰ΩøÁî®Êú¨Âú∞È†êË®≠ÂÄº
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºö‰ΩøÁî®Êú¨Âú∞Â∑•‰ΩúÁ©∫Èñì');
            const data: Workspace[] = [
              {
                id: 'workspace-001',
                name: 'Á∏ΩÈÉ®Ëæ¶ÂÖ¨ÂÆ§',
                description: 'Venturo Á∏ΩÈÉ®Â∑•‰ΩúÁ©∫Èñì',
                icon: 'üè¢',
                is_active: true,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              }
            ];

            set({
              workspaces: data,
              currentWorkspace: data[0] || null,
              loading: false
            });
          }
        } catch (error) {
          console.log('‚ö†Ô∏è ËºâÂÖ•Â∑•‰ΩúÁ©∫ÈñìÂ§±ÊïóÔºå‰ΩøÁî®Êú¨Âú∞È†êË®≠ÂÄº:', error);
          // ÈôçÁ¥öÂà∞Êú¨Âú∞È†êË®≠ÂÄº
          const data: Workspace[] = [
            {
              id: 'workspace-001',
              name: 'Á∏ΩÈÉ®Ëæ¶ÂÖ¨ÂÆ§',
              description: 'Venturo Á∏ΩÈÉ®Â∑•‰ΩúÁ©∫Èñì',
              icon: 'üè¢',
              is_active: true,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            }
          ];

          set({
            workspaces: data,
            currentWorkspace: data[0] || null,
            loading: false
          });
        }
      },

      setCurrentWorkspace: (workspace) => set({ currentWorkspace: workspace }),

      loadBulletins: async (workspaceId) => {
        const currentWorkspaceId = workspaceId || get().currentWorkspace?.id;
        if (!currentWorkspaceId) {
          set({ loading: false });
          return;
        }

        set({ loading: true });
        await new Promise(resolve => setTimeout(resolve, 100));


        const allBulletins = get().bulletins;
        const filtered = allBulletins.filter(b => b.workspace_id === currentWorkspaceId);

        set({ bulletins: filtered, loading: false });
      },

      createBulletin: async (bulletin) => {
        const newBulletin: Bulletin = {
          ...bulletin,
          id: uuidv4(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };

        set(state => ({
          bulletins: [...state.bulletins, newBulletin]
        }));
      },

      updateBulletin: async (id, updates) => {
        set(state => ({
          bulletins: state.bulletins.map(b =>
            b.id === id ? { ...b, ...updates, updated_at: new Date().toISOString() } : b
          )
        }));
      },

      deleteBulletin: async (id) => {
        set(state => ({
          bulletins: state.bulletins.filter(b => b.id !== id)
        }));
      },

      loadChannels: async (workspaceId) => {
        const currentWorkspaceId = workspaceId || get().currentWorkspace?.id;
        if (!currentWorkspaceId) {
          set({ loading: false });
          return;
        }

        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          // ‚ú® 1. Á´ãÂç≥Âæû IndexedDB Âø´ÂèñËÆÄÂèñÔºàÂø´ÔºÅÔºâ
          console.log('üíæ [channels] Âæû IndexedDB Âø´ÈÄüËºâÂÖ•...');
          const cachedChannels = (await localDB.getAll('channels') as Channel[])
            .filter(ch => ch.workspace_id === currentWorkspaceId);

          // Á´ãÂç≥Êõ¥Êñ∞ UIÔºà‰∏çÁ≠â SupabaseÔºâ
          set({ channels: cachedChannels, loading: false });
          console.log(`‚úÖ [channels] IndexedDB Âø´ÈÄüËºâÂÖ•ÂÆåÊàê: ${cachedChannels.length} Á≠Ü`);

          // ‚ú® 2. ËÉåÊôØÂæû Supabase ÂêåÊ≠•Ôºà‰∏çÈòªÂ°û UIÔºâ
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            setTimeout(async () => {
              try {
                console.log('‚òÅÔ∏è [channels] ËÉåÊôØÂêåÊ≠• Supabase...');
                const { data, error } = await supabase
                  .from('channels')
                  .select('*')
                  .eq('workspace_id', currentWorkspaceId)
                  .order('created_at', { ascending: true });

                if (error) {
                  console.warn('‚ö†Ô∏è [channels] Supabase ÂêåÊ≠•Â§±ÊïóÔºåÁπºÁ∫å‰ΩøÁî®Âø´ÂèñË≥áÊñô');
                  return;
                }

                const freshChannels = data || [];
                console.log(`‚úÖ [channels] Supabase ÂêåÊ≠•ÊàêÂäü: ${freshChannels.length} Á≠Ü`);

                // ÊâπÊ¨°Â≠òÂÖ• IndexedDB
                for (const channel of freshChannels) {
                  await localDB.put('channels', channel);
                }

                // ÈùúÈªòÊõ¥Êñ∞ UI
                set({ channels: freshChannels });
              } catch (syncError) {
                console.warn('‚ö†Ô∏è [channels] ËÉåÊôØÂêåÊ≠•Â§±Êïó:', syncError);
              }
            }, 0);
          }
        } catch (error) {
          console.log('‚ö†Ô∏è ËºâÂÖ•È†ªÈÅìÂ§±Êïó:', error);
          set({ loading: false });
        }
      },

      createChannel: async (channel) => {
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        const newChannel: Channel = {
          ...channel,
          id: uuidv4(),
          created_at: new Date().toISOString()
        };

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂØ´ÂÖ• Supabase
            const { error } = await supabase
              .from('channels')
              .insert({
                id: newChannel.id,
                workspace_id: newChannel.workspace_id,
                name: newChannel.name,
                description: newChannel.description,
                type: newChannel.type,
                group_id: newChannel.group_id,
                tour_id: newChannel.tour_id,
                is_favorite: newChannel.is_favorite || false,
                created_by: newChannel.created_by,
                created_at: newChannel.created_at
              });

            if (error) throw error;
            console.log('‚úÖ È†ªÈÅìÂ∑≤ÂêåÊ≠•Âà∞ Supabase');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºöÈ†ªÈÅìÂÉÖÂÑ≤Â≠òÂà∞Êú¨Âú∞');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è È†ªÈÅìÂêåÊ≠•Â§±ÊïóÔºåÂÉÖÂÑ≤Â≠òÂà∞Êú¨Âú∞:', error);
        }

        // ‚ú® ÂêåÊôÇÂØ´ÂÖ• IndexedDB Âíå state
        await localDB.put('channels', newChannel);
        set(state => ({
          channels: [...state.channels, newChannel]
        }));
      },

      loadMessages: async (channelId) => {
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          // ‚ú® 1. Á´ãÂç≥Âæû IndexedDB Âø´ÂèñËÆÄÂèñÔºàÂø´ÔºÅÔºâ
          console.log('üíæ [messages] Âæû IndexedDB Âø´ÈÄüËºâÂÖ•...');
          const cachedMessages = (await localDB.getAll('messages') as Message[])
            .filter(m => m.channel_id === channelId);

          // Á´ãÂç≥Êõ¥Êñ∞ UIÔºà‰∏çÁ≠â SupabaseÔºâ
          set({ messages: cachedMessages });
          console.log(`‚úÖ [messages] IndexedDB Âø´ÈÄüËºâÂÖ•ÂÆåÊàê: ${cachedMessages.length} Á≠Ü`);

          // ‚ú® 2. ËÉåÊôØÂæû Supabase ÂêåÊ≠•Ôºà‰∏çÈòªÂ°û UIÔºâ
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            setTimeout(async () => {
              try {
                console.log('‚òÅÔ∏è [messages] ËÉåÊôØÂêåÊ≠• Supabase...');
                const { data, error } = await supabase
                  .from('messages')
                  .select(`
                    *,
                    author:employees!author_id(id, display_name, avatar)
                  `)
                  .eq('channel_id', channelId)
                  .order('created_at', { ascending: true });

                if (error) {
                  console.warn('‚ö†Ô∏è [messages] Supabase ÂêåÊ≠•Â§±ÊïóÔºåÁπºÁ∫å‰ΩøÁî®Âø´ÂèñË≥áÊñô');
                  return;
                }

                const freshMessages = data || [];
                console.log(`‚úÖ [messages] Supabase ÂêåÊ≠•ÊàêÂäü: ${freshMessages.length} Á≠Ü`);

                // ÊâπÊ¨°Â≠òÂÖ• IndexedDB
                for (const message of freshMessages) {
                  await localDB.put('messages', message);
                }

                // ÈùúÈªòÊõ¥Êñ∞ UI
                set({ messages: freshMessages });
              } catch (syncError) {
                console.warn('‚ö†Ô∏è [messages] ËÉåÊôØÂêåÊ≠•Â§±Êïó:', syncError);
              }
            }, 0);
          }
        } catch (error) {
          console.log('‚ö†Ô∏è ËºâÂÖ•Ë®äÊÅØÂ§±Êïó:', error);
        }
      },

      sendMessage: async (message) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        const newMessage: Message = {
          ...message,
          id: uuidv4(),
          reactions: {},
          created_at: new Date().toISOString(),
          author: message.author
        };

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂØ´ÂÖ• Supabase
            const { error } = await supabase
              .from('messages')
              .insert({
                id: newMessage.id,
                channel_id: newMessage.channel_id,
                author_id: newMessage.author_id,
                content: newMessage.content,
                reactions: newMessage.reactions,
                attachments: newMessage.attachments || [],
                created_at: newMessage.created_at
              });

            if (error) throw error;

            console.log('‚úÖ Ë®äÊÅØÂ∑≤ÂêåÊ≠•Âà∞ Supabase');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºöË®äÊÅØÂÉÖÂÑ≤Â≠òÂà∞Êú¨Âú∞');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Ë®äÊÅØÂêåÊ≠•Â§±ÊïóÔºåÂÉÖÂÑ≤Â≠òÂà∞Êú¨Âú∞:', error);
        }

        // ‚ú® ÂêåÊôÇÂØ´ÂÖ• IndexedDB Âíå state
        await localDB.put('messages', newMessage);
        set(state => ({
          messages: [...state.messages, newMessage]
        }));
      },

      updateMessageReactions: async (messageId, reactions) => {
        set(state => ({
          messages: state.messages.map(m =>
            m.id === messageId ? { ...m, reactions } : m
          )
        }));
      },

      deleteMessage: async (messageId) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂæû Supabase Âà™Èô§
            const { error } = await supabase
              .from('messages')
              .delete()
              .eq('id', messageId);

            if (error) throw error;
            console.log('‚úÖ Ë®äÊÅØÂ∑≤Âæû Supabase Âà™Èô§');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºöË®äÊÅØÂÉÖÂæûÊú¨Âú∞Âà™Èô§');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Ë®äÊÅØÂà™Èô§Â§±ÊïóÔºåÂÉÖÂæûÊú¨Âú∞Âà™Èô§:', error);
        }

        // ÂæûÊú¨Âú∞ state ÁßªÈô§
        set((state) => ({
          messages: state.messages.filter(m => m.id !== messageId)
        }));
      },

      softDeleteMessage: async (messageId) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÊõ¥Êñ∞ Supabase
            const { error } = await supabase
              .from('messages')
              .update({ content: 'Ê≠§Ë®äÊÅØÂ∑≤Ë¢´Âà™Èô§' })
              .eq('id', messageId);

            if (error) throw error;
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Ë®äÊÅØÊõ¥Êñ∞Â§±Êïó:', error);
        }

        // Êõ¥Êñ∞Êú¨Âú∞ state
        set((state) => ({
          messages: state.messages.map(m =>
            m.id === messageId
              ? { ...m, content: 'Ê≠§Ë®äÊÅØÂ∑≤Ë¢´Âà™Èô§' }
              : m
          )
        }));
      },

      updateChannel: async (id, updates) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÊõ¥Êñ∞ Supabase
            const { error } = await supabase
              .from('channels')
              .update(updates)
              .eq('id', id);

            if (error) throw error;
            console.log('‚úÖ È†ªÈÅìÂ∑≤Êõ¥Êñ∞Âà∞ Supabase');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºöÈ†ªÈÅìÂÉÖÊõ¥Êñ∞Âà∞Êú¨Âú∞');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è È†ªÈÅìÊõ¥Êñ∞Â§±ÊïóÔºåÂÉÖÊõ¥Êñ∞Âà∞Êú¨Âú∞:', error);
        }

        // Êõ¥Êñ∞Êú¨Âú∞ state
        set(state => ({
          channels: state.channels.map(ch =>
            ch.id === id ? { ...ch, ...updates } : ch
          )
        }));
      },

      deleteChannel: async (id) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂæû Supabase Âà™Èô§
            const { error } = await supabase
              .from('channels')
              .delete()
              .eq('id', id);

            if (error) throw error;
            console.log('‚úÖ È†ªÈÅìÂ∑≤Âæû Supabase Âà™Èô§');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºöÈ†ªÈÅìÂÉÖÂæûÊú¨Âú∞Âà™Èô§');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è È†ªÈÅìÂà™Èô§Â§±ÊïóÔºåÂÉÖÂæûÊú¨Âú∞Âà™Èô§:', error);
        }

        // ÂæûÊú¨Âú∞ state Âà™Èô§
        set(state => ({
          channels: state.channels.filter(ch => ch.id !== id)
        }));
      },

      toggleChannelFavorite: (id) => {
        set(state => ({
          channels: state.channels.map(ch =>
            ch.id === id ? { ...ch, is_favorite: !ch.is_favorite } : ch
          )
        }));
      },

      createChannelGroup: (group) => {
        const newGroup: ChannelGroup = {
          ...group,
          id: uuidv4(),
          created_at: new Date().toISOString()
        };

        set(state => ({
          channelGroups: [...state.channelGroups, newGroup]
        }));
      },

      toggleGroupCollapse: (id) => {
        set(state => ({
          channelGroups: state.channelGroups.map(g =>
            g.id === id ? { ...g, is_collapsed: !g.is_collapsed } : g
          )
        }));
      },

      setSearchQuery: (query) => set({ searchQuery: query }),
      setChannelFilter: (filter) => set({ channelFilter: filter }),

      // ‚ú® ÂàáÊèõÈ†ªÈÅì
      selectChannel: async (channel) => {
        console.log('üì¢ ÂàáÊèõÈ†ªÈÅì:', channel?.name || 'null');

        // 1. Ê∏ÖÁ©∫Áï∂ÂâçË®äÊÅØÂíåÁõ∏ÈóúË≥áÊñô
        set({
          selectedChannel: channel,
          currentChannel: channel,
          messages: [],
          advanceLists: [],
          sharedOrderLists: []
        });

        // 2. ËºâÂÖ•Êñ∞È†ªÈÅìÁöÑË≥áÊñô
        if (channel) {
          await get().loadMessages(channel.id);
          await get().loadAdvanceLists(channel.id);
          await get().loadSharedOrderLists(channel.id);
        }
      },

      shareAdvanceList: async (channelId, items, currentUserId) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        const listId = uuidv4();
        const advanceItems = items.map(item => ({
          ...item,
          id: uuidv4(),
          status: 'pending' as const
        }));

        const newList: AdvanceList = {
          id: listId,
          channel_id: channelId,
          items: advanceItems,
          created_by: currentUserId,
          created_at: new Date().toISOString()
        };

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂØ´ÂÖ• Supabase
            // 1. Âª∫Á´ã‰ª£Â¢äÊ∏ÖÂñÆ
            const { error: listError } = await supabase
              .from('advance_lists')
              .insert({
                id: listId,
                channel_id: channelId,
                created_by: currentUserId,
                created_at: newList.created_at
              });

            if (listError) throw listError;

            // 2. Âª∫Á´ã‰ª£Â¢äÈ†ÖÁõÆ
            const { error: itemsError } = await supabase
              .from('advance_items')
              .insert(
                advanceItems.map(item => ({
                  id: item.id,
                  advance_list_id: listId,
                  name: item.name,
                  description: item.description,
                  amount: item.amount,
                  advance_person: item.advance_person,
                  status: item.status,
                  created_at: newList.created_at
                }))
              );

            if (itemsError) throw itemsError;
            console.log('‚úÖ ‰ª£Â¢äÊ∏ÖÂñÆÂ∑≤ÂêåÊ≠•Âà∞ Supabase');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºö‰ª£Â¢äÊ∏ÖÂñÆÂÉÖÂÑ≤Â≠òÂà∞Êú¨Âú∞');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è ‰ª£Â¢äÊ∏ÖÂñÆÂêåÊ≠•Â§±ÊïóÔºåÂÉÖÂÑ≤Â≠òÂà∞Êú¨Âú∞:', error);
        }

        // Êõ¥Êñ∞Êú¨Âú∞ state
        set(state => ({
          advanceLists: [...state.advanceLists, newList]
        }));
      },

      processAdvanceItem: async (listId, itemId, paymentRequestId, processedBy) => {
        set(state => ({
          advanceLists: state.advanceLists.map(list =>
            list.id === listId
              ? {
                  ...list,
                  items: list.items.map(item =>
                    item.id === itemId
                      ? {
                          ...item,
                          status: 'completed' as const,
                          payment_request_id: paymentRequestId,
                          processed_by: processedBy,
                          processed_at: new Date().toISOString()
                        }
                      : item
                  )
                }
              : list
          )
        }));
      },

      updateAdvanceStatus: async (listId, itemId, status) => {
        set(state => ({
          advanceLists: state.advanceLists.map(list =>
            list.id === listId
              ? {
                  ...list,
                  items: list.items.map(item =>
                    item.id === itemId ? { ...item, status } : item
                  )
                }
              : list
          )
        }));
      },

      loadAdvanceLists: async (channelId) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        set({ loading: true });

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂæû Supabase ËºâÂÖ•
            // 1. ËºâÂÖ•‰ª£Â¢äÊ∏ÖÂñÆ
            const { data: lists, error: listsError } = await supabase
              .from('advance_lists')
              .select('*')
              .eq('channel_id', channelId)
              .order('created_at', { ascending: true });

            if (listsError) throw listsError;

            // 2. ËºâÂÖ•ÊØèÂÄãÊ∏ÖÂñÆÁöÑÈ†ÖÁõÆ
            const advanceLists: AdvanceList[] = [];
            for (const list of lists || []) {
              const { data: items, error: itemsError } = await supabase
                .from('advance_items')
                .select('*')
                .eq('advance_list_id', list.id)
                .order('created_at', { ascending: true });

              if (itemsError) throw itemsError;

              advanceLists.push({
                ...list,
                items: items || []
              });
            }

            set({ advanceLists, loading: false });
          } else {
            // üì¥ Èõ¢Á∑öÔºöÂæûÊú¨Âú∞ state ËºâÂÖ•
            const allLists = get().advanceLists;
            const filtered = allLists.filter(list => list.channel_id === channelId);
            set({ advanceLists: filtered, loading: false });
          }
        } catch (error) {
          console.log('‚ö†Ô∏è ËºâÂÖ•‰ª£Â¢äÊ∏ÖÂñÆÂ§±ÊïóÔºå‰ΩøÁî®Êú¨Âú∞Ë≥áÊñô:', error);
          // ÈôçÁ¥öÂà∞Êú¨Âú∞Ë≥áÊñô
          const allLists = get().advanceLists;
          const filtered = allLists.filter(list => list.channel_id === channelId);
          set({ advanceLists: filtered, loading: false });
        }
      },

      deleteAdvanceList: async (listId) => {
        // supabase client already imported at top
        const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

        try {
          if (isOnline && process.env.NEXT_PUBLIC_ENABLE_SUPABASE === 'true') {
            // üåê ÊúâÁ∂≤Ë∑ØÔºöÂæû Supabase Âà™Èô§ÔºàÊúÉËá™ÂãïÂà™Èô§ÈóúËÅØÁöÑ itemsÔºåÂõ†ÁÇ∫Êúâ ON DELETE CASCADEÔºâ
            const { error } = await supabase
              .from('advance_lists')
              .delete()
              .eq('id', listId);

            if (error) throw error;
            console.log('‚úÖ ‰ª£Â¢äÊ∏ÖÂñÆÂ∑≤Âæû Supabase Âà™Èô§');
          } else {
            console.log('üì¥ Èõ¢Á∑öÊ®°ÂºèÔºö‰ª£Â¢äÊ∏ÖÂñÆÂÉÖÂæûÊú¨Âú∞Âà™Èô§');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è ‰ª£Â¢äÊ∏ÖÂñÆÂà™Èô§Â§±ÊïóÔºåÂÉÖÂæûÊú¨Âú∞Âà™Èô§:', error);
        }

        // ÂæûÊú¨Âú∞ state Âà™Èô§
        set(state => ({
          advanceLists: state.advanceLists.filter(list => list.id !== listId)
        }));
      },

      shareOrderList: async (channelId, orderIds, currentUserId) => {

        const { useOrderStore } = await import('./index');
        const allOrders = useOrderStore.getState().items;

        const orders = orderIds
          .map(orderId => {
            const order = allOrders.find(o => o.id === orderId);
            if (!order) return null;

            const totalCost = order.total_amount || 0;
            const collected = order.paid_amount || 0;
            const gap = totalCost - collected;
            const collectionRate = totalCost > 0 ? (collected / totalCost) * 100 : 0;

            return {
              id: order.id,
              order_number: order.order_number,
              contact_person: order.contact_person || '',
              total_amount: totalCost,
              paid_amount: collected,
              gap,
              collection_rate: collectionRate,
              invoice_status: 'not_invoiced' as const,
              receipt_status: 'not_received' as const
            };
          })
          .filter(Boolean) as any[];

        const newList: SharedOrderList = {
          id: uuidv4(),
          channel_id: channelId,
          orders,
          created_by: currentUserId,
          created_at: new Date().toISOString()
        };

        set(state => ({
          sharedOrderLists: [...state.sharedOrderLists, newList]
        }));
      },

      updateOrderReceiptStatus: async (listId, orderId, receiptId) => {
        set(state => ({
          sharedOrderLists: state.sharedOrderLists.map(list =>
            list.id === listId
              ? {
                  ...list,
                  orders: list.orders.map(order =>
                    order.id === orderId
                      ? { ...order, receipt_status: 'received' as const }
                      : order
                  )
                }
              : list
          )
        }));
      },

      loadSharedOrderLists: async (channelId) => {
        set({ loading: true });
        await new Promise(resolve => setTimeout(resolve, 100));

        const allLists = get().sharedOrderLists;
        const filtered = allLists.filter(list => list.channel_id === channelId);

        set({ sharedOrderLists: filtered, loading: false });
      },

      clearError: () => set({ error: null })
    }),
    {
      name: 'workspace-storage',
      partialize: (state) => ({
        workspaces: state.workspaces,
        currentWorkspace: state.currentWorkspace,
        bulletins: state.bulletins,
        channels: state.channels,
        channelGroups: state.channelGroups,
        selectedChannel: state.selectedChannel,  // ‚ú® Ë®ò‰ΩèÊúÄÂæåÈÅ∏ÊìáÁöÑÈ†ªÈÅì
        messages: state.messages,
        advanceLists: state.advanceLists,
        sharedOrderLists: state.sharedOrderLists
      })
    }
  )
);
